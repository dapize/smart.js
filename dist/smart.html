(function (root) {
'use strict';
  /**
 * Utilidades varias
 * @namespace uSchema
 * @property {Array} typesAccepted Lista de tipos aceptados para ser procesados.
 */
const uSchema = {

  /**
   * Verifica si lo pasado es un objeto literal o no
   * @memberof uSchema
   * @param {Object} obj Objeto a ser verificado
   * @returns {Boolean}
   * @example
   * uSchema.objLiteral({});
   * => true
   * @example
   * uSchema.objLiteral('obj');
   * => false
   */
  objLiteral: function (obj) {
    return Object.prototype.toString.call(obj).toLowerCase() === '[object object]'
  },

  typesAccepted: ['string', 'number', 'boolean', 'array', 'object'],

  /**
   * Devuelve el tipo de dato de una propiedad en un ojeto
   * @memberof uSchema
   * @namespace getType
   */
  getType: {
    /**
     * Devuelve el tipo de dato de una propiedad de un objeto comun y corriente.
     * @memberof uSchema.getType
     * @param {*} value Valor de la propiedad del objeto a obtener su tipo.
     * @returns {String} 'string', 'number', 'boolean', 'array' u 'object
     */
    obj: function (value) {
      return Array.isArray(value) ? 'array' : typeof value;
    },

    /**
     * Devuelve el tipo de dato de una propiedad de un objeto schema.
     * @memberof uSchema.getType
     * @param {*} value Valor de la propiedad del objeto a obtener su tipo.
     * @returns {String} 'string', 'number', 'boolean', 'array' u 'object
     */
    schema: function (value) {
      let retorno;
      if (Array.isArray(value)) {
        retorno = 'mixed';
      } else {
        if (uSchema.objLiteral(value)) {
          retorno = value.hasOwnProperty('type') ? value.type : 'object';
        } else {
          const typeOfVal = typeof value;
          if (typeOfVal === 'string') {
            retorno = (uSchema.typesAccepted.indexOf(value) !== -1) ? value : typeOfVal;
          } else {
            retorno = typeOfVal
          }
        }
      }
      return retorno;
    }
  },

  /**
   * Registra incidentes dentro de un objeto, para que sirva de log o para el compilado.
   * @memberof uSchema
   * @param {Array|Object} target Lista y objeto destino.
   * @param {Object|String} data Objeto que contendrá información de la propiedad faltante o tambien el string que será agregado al array.
   * @param {String=} propName Nombre de la propiedad a crear dentro del objeto.
   * @returns {Boolean} Registro exitoso: true. Intento de registro duplicado: false
   */
  reg: function (target, data, propName) {
    let retorno = false;
    if (propName) { // if exists this argument the target is a 'object'...
      if (!target.hasOwnProperty(propName)) {
        target[propName] = data;
        retorno = true;
      }
    } else { // ... is not is a 'array'
      target.push(data);
      retorno = true;
    }
    return retorno;
  },

  /**
   * Realiza un merge de los registros obtenidos por el tratado de un subschema.
   * @memberof uSchema
   * @param {Object} target Objeto destino en donde se realizará el merge de las propiedades.
   * @param {Object} schema Objeto que contiene los registros (missings, errors, different)
   * @param {String} parentProp Nombre de la propiedad padre de los registros
   * @returns {Object}
   */
  mergeProps: function (target, schema, parentProp) {
    // ERRORS
    const itemReg = schema.errors;
    if (itemReg.length) target.errors = target.errors.concat(itemReg);
    
    // MISSINGS
    let missing;
    ['required', 'optional'].forEach(function (item) {
      missing = schema.missings[item];
      if (missing.length) target.missings[item] = target.missings[item].concat(missing);
    });
    
    // DIFFERENT AND COMPILED
    let currentSchema;
    ['different', 'compiled'].forEach(function (objName) {
      currentSchema = schema[objName];
      if (Object.keys(currentSchema).length) {
        if (!target[objName].hasOwnProperty(parentProp)) target[objName][parentProp] = {};
        target[objName][parentProp] = currentSchema;
      };
    });
  }

};

/**
 * Constructor del schema.
 * @constructor
 * @param {Object} obj Configuraciones iniciales del schema
 * @example
 * const mySchema = {
 *  name: 'string',
 *  age: 'number',
 *  email: {
 *    type: 'string',
 *    required: true
 *  }
 * }
 * const card = new Schema(schema);
 */
function Schema (obj) {
  this.schema = Object.assign({}, obj);
  this.missings = {
    required: [],
    optional: []
  };
  this.different = {};
  this.errors = [];
  this.compiled = {};
};

/**
 * Fusiona el objeto pasado con el schema creado
 * @param {Object} [obj] Objeto que se necesita compilar con el squema creado.
 * @returns {Object} El objeto fusionado con los valores por defecto en el esquema (si es que existen claro).
 */
Schema.prototype.compile = function (obj) {
  if (obj) this.validate(obj);
  return this.missings.required.length ? false : this.compiled;
};

/**
 * Valida si un objeto cumple con el schema designado.
 * @param {Object} response Objeto que comunmente se obtiene de un 'response' en una solicitud ajax
 * @returns {Boolean} Indica si el objeto pasado es válido o no con el schema.
 */
Schema.prototype.validate = function (response) {
  const schema = this.schema,
        _this = this;
  let retorno = true; // by default, is valid :)

  Object.keys(schema).forEach(function (property) {
    // Data form schema
    const valPropSchema = schema[property];
    const getTypeValSchema = uSchema.getType.schema(valPropSchema);

    if (response.hasOwnProperty(property)) {
      // Data from response
      const valPropObj = response[property];
      const getTypeValObj = uSchema.getType.obj(valPropObj);

      switch (getTypeValSchema) {
        case 'string':
        case 'number':
        case 'boolean':
        case 'array':
          if (getTypeValSchema !== getTypeValObj) {
            if (valPropSchema.required) retorno = false;
            uSchema.reg(_this.different, {
              current: getTypeValObj,
              expected: getTypeValSchema,
              value: valPropObj
            }, property);
          } else {
            uSchema.reg(_this.compiled, valPropObj, property)
          }
          break;
        
        case 'object':
          if (getTypeValObj === 'object') {
            if (valPropSchema.hasOwnProperty('properties')) {
              const propertiesSchema = new Schema(valPropSchema.properties);
              if (!propertiesSchema.validate(valPropObj)) retorno = false;
              uSchema.mergeProps(_this, propertiesSchema, property);
            } else {
              uSchema.reg(_this.compiled, valPropObj, property);
            }
          } else {
            if (valPropSchema.required) {
              retorno = false;
              uSchema.reg(_this.different, {
                current: getTypeValObj,
                expected: getTypeValSchema,
                value: valPropObj
              }, property);
            }
          }
          break;
        
        case 'mixed':
          const typesValid = valPropSchema.filter(function (type) {
            return type === getTypeValObj;
          });
          // no body match with any types items.
          if (!typesValid.length && valPropSchema.required) { 
            retorno = false;
            uSchema.reg(_this.different, {
              current: getTypeValObj,
              expected: valPropSchema,
              value: valPropObj
            }, property);
          } else {
            uSchema.reg(_this.compiled, valPropObj, property)
          }
          break;

        default:
          console.log('format type dont accepted: ' + getTypeValSchema);
          retorno = false;
      }
    } else {
      let missing;
      if (valPropSchema.required) {
        retorno = false;
        missing = 'required';
      } else {
        missing = 'optional';
      }
      uSchema.reg(_this.missings[missing], property);
      if (valPropSchema.default) _this.compiled[property] = valPropSchema.default;
    }
  });

  // Returning
  return retorno;
};

/**
 * Utilidad para retornar errores.
 * @param {String} type Tipo de error a mostrar
 * @param {String} message Descripción del error
 */
const regError = function (name, message) {
  const err = new Error();
  err.name = name;
  err.message = message;
  console.log(err);
  return err;
};

/**
 * Crea la instancia principal del 'Smart'
 * @constructor
 * @param {obj} obj Objeto con configuraciones
 * @returns {Smart} Instancia del constructor 'Smart'
 */
function Smart(obj) {
  if (!obj) obj = {};
  SmartEvents.call(this);
  this.components = new Map();
  this.modules = new Map();
};
Smart.prototype = Object.create(SmartEvents.prototype);
Smart.prototype.constructor = Smart;

/**
 * Creador de un 'Smart Event'.
 * @constructor
 */
function SmartEvents () {
  this.events = null;
};

/**
 * Se suscribe a un evento
 * @param {String} name Nombre del evento a suscribirce.
 * @param {Function} cb Callback del evento.
 */
SmartEvents.prototype.addEventListener = function (name, cb){
  if (!this.events) this.events = {};
  (this.events[name]) ? this.events[name].push(cb) : this.events[name] = [cb];
};

/**
 * Dispara las funciones anidadas a un evento determinado adjunto.
 * @param {String} name Nombre del evento
 * @param {*} [data1] Data arbitraria pasada en el disparo del evento.
 * @param {*} [data2] Data arbitraria pasada en el disparo del evento.
 */
SmartEvents.prototype.dispatchEvent = function (name, data1, data2) {
  if (this.events && this.events[name]) {
    const _this = this
    this.events[name].forEach(function (cb) {
      cb.call(_this, data1, data2);
    })
  }
};

/**
 * Elimina un evento suscrito. Si no se determina una función en el segundo parametro, todos las funciones suscritas al evento serán removidas.
 * @param {String} name Nombre del evento a desuscribirce.
 * @param {Function} [cb] Function a desuscribir del evento.
 */
SmartEvents.prototype.removeEventListener = function (name, cb) {
  if (this.events && this.events[name]) {
    const event = this.events[name];
    if (event) {
      if (cb === undefined) {
        delete this.events[name];
      } else {
        const nEvents = event.length;
        let e;
        for (e = 0; e < nEvents; e++) {
          if (event[e] === cb) {
            this.events[name].splice(e, 1);
            if (!this.events[name].length) delete this.events[name];
            break;
          }
        }
      }
      // Nuleamos si no hay ningún evento.
      if (!Object.keys(this.events).length) this.events = null;
    }
  }
};

/**
 * Constructor de un 'Smart Element'
 * @constructor
 * @param {String} name Nombre del elemento.
 * @param {Object} [obj] Objeto de opciones del elemento.
 */
Smart.prototype.registerComponent = function (name, obj) {
  if (typeof name !== 'string') return regError('Nombre Inadecuado', 'No se declaró correctamente el nombre del componente a registrar.');
  if (this.components.has(name)) return regError('Componente Duplicado', 'Ya se había registrado el componente "' + name + '".');
  if (!obj) obj = {};

  // Creating constructor
  function SmartRegisterComponent () {
    SmartEvents.call(this, name);
  };
  SmartRegisterComponent.prototype = Object.create(SmartEvents.prototype);
  SmartRegisterComponent.prototype.constructor = SmartRegisterComponent;


  // Saving in vault
  const componentsOptions = {
    styles: obj.styles || null,
    schema: obj.schema || null,
    template: obj.template || null,
    constructor: SmartRegisterComponent,
    instance: new SmartRegisterComponent()
  };
  this.components.set(name, componentsOptions);

  // Notifier
  const notiData = Object.assign({}, componentsOptions);
  delete notiData.constructor;
  delete notiData.instance;

  // Noti global
  this.dispatchEvent('component:registered', name, notiData);

  // Noti local
  setTimeout(function () {
    componentsOptions.instance.dispatchEvent('registered', notiData);
  }, 0);
  
  return componentsOptions.instance;
};


/**
 * Crea un 'Smart Node' tipo elemento.
 * @param {String} name nombre del 'Smart Node' a crear.
 */
Smart.prototype.createComponent = function (name, obj) {
  if (!obj) obj = {};
  if (!this.components.has(name)) return regError('Componente Inexistente', 'No se puede crear el componente "' + name + '", porque no está registrado.');

  // Getting componente
  const component = this.components.get(name);

  // Building Data (with the schema)
  let cData = null;
  if (component.hasOwnProperty('schema')) {
    const cSchema = new Schema(component.schema);
    if (!cSchema.validate(obj)) return regError('Data inválida', 'No fué posible crear el componente "' + name + '", ya que su data es inválida.');
    cData = cSchema.compile();
  };

  // Building template
  let cTemplate = null;
  if (component.hasOwnProperty('template')) {
    // creating DOM Nodes
    const divTemp = document.createElement('div');
    divTemp.innerHTML = Mustache.render(component.template, cData);
    cTemplate = divTemp.firstChild;
  };

  // Executing the script
  if (component.hasOwnProperty('script')) {
    const _this = this;
    if (cTemplate) {
      const ctargets = cTemplate.querySelectorAll('[component]');
      if (ctargets.length) {
        Array.prototype.forEach.call(ctargets, function (target) {
          component.script.call(_this, target, cData);
        });
      }
    } else {
      component.script.call(_this, null, cData);
    }
  };

  // Inserting styles, if have styles
  if (component.hasOwnProperty('styles')) {
    const tagStyle = document.createElement('style');
    tagStyle.type = 'text/css';
    tagStyle.innerHTML = component.styles;
    tagStyle.id = name;
    document.body.appendChild(tagStyle);
  };

  // Noti global
  this.dispatchEvent('component:registered', name, cTemplate);

  // Noti local
  setTimeout(function () {
    component.instance.dispatchEvent('created', cTemplate);
  }, 0);

  // Return instance
  return component.instance;
};


  // EXPORTING
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      module.exports = Smart;
    }
    exports.Smart = Smart;
  } else {
    root.Smart = Smart;
  }
}(this));